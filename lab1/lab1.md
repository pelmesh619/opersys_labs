# Лабораторная работа №1

Bash - это язык, с помощью которого устанавливается основное взаимодействие с операционной системой Linux. До Bash (Bourne Again SHell) был просто Bourne Shell

## Синтаксис

Bash - язык интерпретируемый. Так выглядит простая программа на Bash:

```bash
#!/usr/bin/bash
# это шебанг в начале файла, он указывает интерпретатор
# вместо него может быть, например, путь к интерпретатору Python

# Комментарий начинается с #
echo "Привет, мир!"   # Вывод текста
```

Переменные присваиваются с помощью `=`, а значение возвращается по `$`

```bash
name="Алиса"
echo $name         # Алиса
echo "${name}!"    # Алиса!

count=5
```

Все переменные в Bash - строки. При использовании арифметики они автоматически преобразуются в числа (пустая строка считается нулем):

```bash
a=5
b=3

echo $((a + b))       # 8
((sum = a * b))        # можно так
echo $sum              # 15
```

Чтение строки осуществляется с помощью `read`

```bash
read name              # Чтение строки
read -p "Введите имя: " name   # -p задает выводимый при вводе текст
echo "Привет, $name!"
```

Условия производятся так:

```bash
if [ $a -gt $b ]; then
    echo "a > b"
elif [ $a -eq $b ]; then
    echo "a == b"
else
    echo "a < b"
fi

# или
if [ $a -gt $b ]
then
    echo "a > b"
fi
```

В Bash есть следующие операторы сравнения чисел:

| Оператор | Значение         | Пример        | Результат |
| -------- | ---------------- | ------------- | --------- |
| `-eq`    | равно            | `[ 3 -eq 3 ]` | true      |
| `-ne`    | не равно         | `[ 3 -ne 5 ]` | true      |
| `-lt`    | меньше чем       | `[ 2 -lt 5 ]` | true      |
| `-le`    | меньше или равно | `[ 5 -le 5 ]` | true      |
| `-gt`    | больше чем       | `[ 8 -gt 3 ]` | true      |
| `-ge`    | больше или равно | `[ 8 -ge 8 ]` | true      |

Операторы сравнения строк:

| Оператор | Значение                                 | Пример             | Результат            |
| -------- | ---------------------------------------- | ------------------ | -------------------- |
| `=`      | строки равны                             | `[ "$a" = "$b" ]`  | true, если одинаковы |
| `==`     | строки равны (в `[[ ]]`)                 | `[[ $a == $b ]]`   | true                 |
| `!=`     | строки не равны                          | `[ "$a" != "$b" ]` | true                 |
| `<`      | первая строка меньше (лексикографически) | `[[ $a < $b ]]`    | true                 |
| `>`      | первая строка больше (лексикографически) | `[[ $a > $b ]]`    | true                 |
| `-z`     | строка пуста                             | `[ -z "$a" ]`      | true, если пустая    |
| `-n`     | строка не пуста                          | `[ -n "$a" ]`      | true, если непустая  |

Файловые операторы:

| Оператор          | Проверяет                     | Пример                | Истинно, если                       |
| ----------------- | ----------------------------- | --------------------- | ----------------------------------- |
| `-e`              | существует файл или каталог   | `[ -e file.txt ]`     | файл или папка есть                 |
| `-f`              | обычный файл                  | `[ -f file.txt ]`     | файл существует и это не директория |
| `-d`              | директория                    | `[ -d /etc ]`         | папка существует                    |
| `-s`              | файл не пуст                  | `[ -s file.txt ]`     | размер > 0                          |
| `-r`              | читается                      | `[ -r file.txt ]`     | есть права на чтение                |
| `-w`              | записывается                  | `[ -w file.txt ]`     | есть права на запись                |
| `-x`              | исполняется                   | `[ -x script.sh ]`    | можно запустить                     |
| `-L` или `-h`     | символическая ссылка          | `[ -L link ]`         | true, если это symlink              |
| `-O`              | владелец текущий пользователь | `[ -O file.txt ]`     | true                                |
| `-G`              | группа совпадает с текущей    | `[ -G file.txt ]`     | true                                |
| `file1 -nt file2` | "newer than" - новее          | `[ file1 -nt file2 ]` | true, если file1 новее              |
| `file1 -ot file2` | "older than" - старше         | `[ file1 -ot file2 ]` | true, если file1 старше             |

Логические операторы:

| Оператор | Значение                           | Пример                           |                                      |          |   |          |
| -------- | ---------------------------------- | -------------------------------- | ------------------------------------ | -------- | - | -------- |
| `!`      | логическое отрицание               | `[ ! -f file.txt ]`              |                                      |          |   |          |
| `-a`     | логическое И (в старом стиле)      | `[ -f file.txt -a -r file.txt ]` |                                      |          |   |          |
| `-o`     | логическое ИЛИ (в старом стиле)    | `[ -d dir -o -f file.txt ]`      |                                      |          |   |          |
| `&&`     | логическое И (современный вариант) | `[[ -f f && -r f ]]`             |                                      |          |   |          |
| `        |                                    | `                                | логическое ИЛИ (современный вариант) | `[[ -d d |   | -f f ]]` |

---

В Bash есть 3 типа циклов:

```bash
for i in 1 2 3; do
  echo "Число: $i"
done

for ((i=1; c <= 3; i++)); do
  echo "Число: $i"
done

for f in *.txt; do
  echo "Файл: $f"
done
```

```bash
count=0
while [ $count -lt 5 ]; do
  echo $count
  ((count++))
done # выполняет, пока условие истинно
```

```bash
until [ $count -eq 5 ]; do
  ((count++))
done # выполняет, пока условие ложно
```

Циклы управляют также с помощью `break` и `continue`

---

В Bash можно объявить функции:

```bash
myfunc() {
  echo "Аргумент 1: $1"
  return 0
}

myfunc "тест"
```

Аргументы функции можно получить через `$1`, `$2` и так далее, все аргументы - `$@`, их количество - `$#`

Другие специальные переменные в Bash:

| Переменная | Что хранит |
|-|-|
| $$ | айди процесса текущего интерпретатора |
| $! | айди последнего процесса в фоновом режиме |
| $? | код возврата последнего процесса (или функции) |
| $* | все аргументы в виде одной строки |
| $- | список флагов, переданных скрипту |
| $_ | последний аргумент предыдущей команды |
| $UID | идентификатор пользователя |
| $HOME | домашний каталог пользователя |
| $HOSTNAME | имя компьютера |
| $HOSTTYPE | архитектура компьютера |
| $PWD | каталог, с которого скрипт был запущен |
| $OSTYPE | тип операционной системы |
| $PATH | глобальный путь |
| $PPID | айди родительского процесса |
| $SECONDS | время работы скрипта в секундах |

---

В Bash есть три потока: поток ввода `0`, поток вывода `1` и поток ошибок `2`

| `0< filename` или `< filename` | Перенаправление ввода из файла |
| `1> filename` или `> filename` | Перенаправление вывода в файл с его перезаписью (если установлена команда `set -o noclobber`, то при непустом файле возникнет ошибка) |
| `1>\| filename` или `>\| filename` | Перенаправление вывода в файл с его перезаписью |
| `1>> filename` или `>> filename` | Перенаправление вывода в файл, содержимое дописывается в конце |
| `2> filename` | Перенаправление ошибок в файл |
| `2>> filename` | Перенаправление ошибок в файл, содержимое дописывается в конце |
| `&> filename` | Перенаправление вывода и ошибок в файл |
| `2>&1` | Перенаправление ошибок на стандартный вывод |

Вывод команды можно сохранить в переменную:

```bash
date=$(date)
echo "Сегодня: $date"
```

Также команды можно соединять в одну строку:

```bash
command1 && command2   # вызовет command2, если command1 вернул нулевой код возврата
command1 || command2   # вызовет command2, если command1 вернул ненулевой код возврата
command1 | command2    # перенаправляет поток вывода command1 в поток ввода command2
```

---

Массивы в Bash создаются так:

```bash
# Явное объявление
declare -a array

# Инициализация значениями
fruits=("apple" "banana" "cherry")
numbers=(1 2 3 4 5)

# Поэлементное присваивание
fruits[0]="apple"
fruits[1]="banana" 
fruits[2]="cherry"
```

Доступ к элементам:

```bash
# Первый элемент
echo "${fruits[0]}"    # apple

# Все элементы
echo "${fruits[@]}"    # apple banana cherry

# Все элементы как отдельные слова
for fruit in "${fruits[@]}"; do
    echo "$fruit"
done
# Итерация по индексам:
for i in "${!fruits[@]}"; do
    echo "Индекс $i: ${fruits[i]}"
done

# Индексы массива
echo "${!fruits[@]}"   # 0 1 2
```

Другие операции:

```bash
# Длина массива
echo "Длина: ${#fruits[@]}"  # 3

# Длина элемента
echo "Длина 0-го: ${#fruits[0]}"  # 5

# Добавление элементов
fruits+=("orange")           # в конец
fruits=("grape" "${fruits[@]}")  # в начало

# Удаление элементов
unset fruits[1]              # удалить banana
```

Также в Bash есть ассоциативные массивы (словари):

```bash
# Объявление ассоциативного массива
declare -A dict

# Инициализация
declare -A user=(
    ["name"]="John"
    ["age"]="25"
    ["city"]="London"
)

# Поэлементное присваивание
dict["key1"]="value1"
dict["key2"]="value2"
```

```bash
# Получить значение
echo "${user["name"]}"    # John

# Все значения
echo "${user[@]}"         # John 25

# Все ключи
echo "${!user[@]}"        # name age

# Проверка существования ключа
if [[ -v user["name"] ]]; then
    echo "Ключ существует"
fi
```

Итерация по словарю:

```bash

# По ключам
for key in "${!user[@]}"; do
    echo "$key: ${user[$key]}"
done

# Сортировка ключей
for key in $(echo "${!user[@]}" | tr ' ' '\n' | sort); do
    echo "$key: ${user[$key]}"
done
```

## Скрипт №1

Выводим наибольшее число из трех:

```bash
#!/usr/bin/bash

if [[ $1 -gt $2 ]]
    then if [[ $1 -gt $3 ]]
        then echo $1
        else echo $3
    fi
    else 
    if [[ $2 -gt $3 ]]
        then echo $2
        else echo $3
    fi
fi
```

> Файлы: [1.sh](./1.sh)

## Скрипт №2

Дополняем строку пользовательский вводом до тех пор, пока не встретим `q`:

```bash
#!/usr/bin/bash

a=""
b=""

while [[ $b != "q" ]]
do 
	read b
	a="$a$b"
done

echo $a

```

> Файлы: [2.sh](./2.sh)

## Скрипт №3

Предлагаем выбрать, какую программу открыть, и открываем:

```bash
#!/usr/bin/bash

echo -e "1 - nano\n2 - vi\n3 - links\n4 - exit"

read a
case $a in 
1) 
	nano 
	;;
2) 
	vi 
	;;
3) 
	links 
	;;
4) 
	;;
*) 
	echo "Wrong command" ;;

esac
```

> Файлы: [3.sh](./3.sh)

## Скрипт №4

Проверяет, запущен ли скрипт из домашней директории:

```bash
#!/usr/bin/bash

if [[ $PWD == $HOME ]]
then echo "Welcome home"
	exit 0
else echo "ERROR: THIS IS NOT MY HOME!"
	exit 1
fi
```

> Файлы: [4.sh](./4.sh)

## Скрипт №4

Проверяет, запущен ли скрипт из домашней директории:

```bash
#!/usr/bin/bash

if [[ "$PWD" == "$HOME" ]]
then echo "Welcome home"
	exit 0
else echo "ERROR: THIS IS NOT MY HOME!"
	exit 1
fi
```

> Файлы: [4.sh](./4.sh)

## Скрипт №5

Находим файл `/var/log/anaconda/syslog`, `/var/log/installer/syslog` или любой другой лог, где есть `INFO`, и запускаем `awk` в директории этого лога (или копируем файл туда, где хотим исполнить скрипт):

```bash
#!/usr/bin/bash

awk '{
	if ($2 = "INFO") 
        print $0;
}' ./syslog > info.log
```

> Файлы: [5.sh](./5.sh)

## Скрипт №6

Заменяем в логе метку строки и выводим в сортированном порядке

```bash
#!/usr/bin/bash

awk '{ if ($3 == "(II)" || $3 == "(WW)") print $0 }' ./X.log | sed 's/(II)/Information:/' | sed 's/(WW)/Warning:/' | sort -k3 -r > full.log 
```

Флаги:

* `sort -r` означает обратный порядок сортировки (reverse)
* `sort -k3` - третье слово в строке

> Файлы: [6.sh](./6.sh)

## Скрипт №7

Выводим почтовые адреса из `/etc/` через запятую

```bash
#!/usr/bin/bash

grep -roE "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}" /etc/ | cut -d':' -f 2 | paste -s | sed "s/\t/, /g" > ./emails.lst
```

Флаги:

* `grep -r` - рекурсивный поиск по директории (от recursive)
* `grep -o` - выводить только совпавшую часть (от only matching)
* `grep -E` - включить расширенные регулярные выражения (от extended)
* `cut -d':'` - разделять по `:` (от delimiter)
* `cut -f 2` - вывести второй элемент (от field)
* `paste -s` - объединить построчно (от serial)

> Файлы: [7.sh](./7.sh)

## Скрипт №8

Выводим имена и идентификаторы пользователей

```bash
#!/usr/bin/bash

awk -F: '{ print $3, $1 }' /etc/passwd | sort -n
```

Флаги:

* `awk -F:` - разделять по `:`
* `sort -n` - сортировать первое поле как число

> Файлы: [8.sh](./8.sh)

## Скрипт №9

Выводим имена и идентификаторы пользователей

```bash
#!/usr/bin/bash

a=0

while read -r line 
do
	a=$(( a + $(cat "$line" | wc -l) ))
done < <(find /var/log/ -type f -name '*.log')

echo $a
```

Флаги:

* `read -r` - сохраняет обратные слеши (отдает `\n` вместо новой строки)
* `wc -l` - считать строки, а не слова
* `-type f` - искать файлы
* `-name '*.log'` - с именем, подходящим под такой паттерн

> Файлы: [9.sh](./9.sh)

## Скрипт №10

Выводим три наиболее встречающихся слова из `man` длиной не менее 4 символа

```bash
#!/usr/bin/bash

declare -A dict

while read word;
do
	if [[ -n ${dict[$word]} ]]
	then dict[$word]=$(( ${dict[$word]}+1 ))
	else dict[$word]="1"
	fi
done < <(man -E 'UTF-8' bash | grep -oiE "[a-z]{4,}") 

for word in "${!dict[@]}"
do
	echo "$word ${dict[$word]}"
done | sort -rn -k2 | head -n 3
```

Флаги:

* `man -E 'UTF-8'` - устанавливает кодировку `UTF-8`
* `grep -i` - игнорировать регистр
* `sort -n` - сортировать поле как число
* `sort -r` - обратный порядок сортировки
* `sort -k2` - сравнивать второе поле
* `head -n 3` - вывести первые три строки

> Файлы: [10.sh](./10.sh)
